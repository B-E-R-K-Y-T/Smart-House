{
    "base_client.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\nimport socket\n\n\n# noinspection PyGlobalUndefined\nclass Client:\n    client = None\n\n    def __init__(self, ip: str, port: int):\n        global client\n\n        client = socket.socket(\n            socket.AF_INET,\n            socket.SOCK_STREAM\n        )\n        client.connect((ip, port))\n\n    @staticmethod\n    def get_client():\n        global client\n        return client\n\n    @staticmethod\n    def send_msg(data: str):\n        global client\n        client.send(data.encode('utf-8'))\n        print('Запрос отправлен.')\n\n    @staticmethod\n    def recv_msg():\n        global client\n        return client.recv()\n",
    "base_server.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n# Базовый класс сервера\n\n# ----------------------------------------------------------------------------------------------------------------------\n\nimport asyncio\n\nfrom shm_exceptions import ExceptionErrorProtocol\nfrom shm_protocols import TCPServerProtocol\n\n\nclass Server(TCPServerProtocol):\n    def __init__(self, host, port, protocol='TCP'):\n        print(f'<SERVER>: '\n              f'Address: {host}; '\n              f'Port: {port}; '\n              f'Protocol: {protocol} '\n              f'Status: Activating...')\n        asyncio.run(self.start_server(host, port, protocol))\n\n    @staticmethod\n    async def start_server(host, port, protocol):\n        loop = asyncio.get_running_loop()\n\n        protocols = {'MQTT': '',\n                     'AQMP': '',\n                     'COAP': '',\n                     'TCP': TCPServerProtocol(),\n                     'udp': '',\n                     'http': ''}\n\n        for prot in protocols.keys():\n            if protocol == prot and protocols[prot]:\n                server = await loop.create_server(\n                    lambda: protocols[prot],\n                    host, port)\n\n                break\n        else:\n            raise ExceptionErrorProtocol('I do not know such a protocol :(')\n\n        async with server:\n            # Метод Server.serve_forever() начинает принимать\n            # подключения, пока сопрограмма не будет отменена.\n            # Отмена задачи serve_forever приводит к закрытию сервера.\n            #\n            # Представляет собой сопрограмму.\n            #\n            # Этот метод можно вызвать, если сервер уже принимает\n            # соединения. На один объект Server может существовать\n            # только одна задача Server.serve_forever().\n            await server.serve_forever()\n",
    "bot_authorization_mode.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n# Апишка для авторизации пользователей\n\n# ----------------------------------------------------------------------------------------------------------------------\n\nimport csv\n\nfrom parse_files import create_csv_file_if_not_exists\n\nname_file = 'users.csv'\n\n\nasync def check_exist_user(user_id):\n    await create_csv_file_if_not_exists(name_file)\n\n    with open(name_file, 'r') as f:\n        # Создаем объект DictReader, указываем символ-разделитель \",\"\n        file_reader = csv.DictReader(f, delimiter=\",\")\n        # Считывание данных из CSV файла\n        for row in file_reader:\n            if str(user_id) == str(row['ID']):\n                return True\n        else:\n            return False\n\n\nasync def sign_up(login, password):\n    await create_csv_file_if_not_exists(name_file)\n\n    with open(name_file, 'r') as f:\n        # Создаем объект DictReader, указываем символ-разделитель \",\"\n        file_reader = csv.DictReader(f, delimiter=\",\")\n        # Считывание данных из CSV файла\n        for row in file_reader:\n            if login == row['Login'] and password == row['Password']:\n                return True\n        else:\n            return False\n",
    "bot_controller.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n# Бот для взаимодействия с сервером\n\n# ----------------------------------------------------------------------------------------------------------------------\n\nimport csv\nimport logging\nimport sys\nimport base_client\nimport bot_reg_mode\nimport bot_authorization_mode\n\n\nmain_directory = __file__[:str(__file__).rfind('/')]\nsys.path.append(main_directory)\n\n\nfrom aiogram.contrib.fsm_storage.memory import MemoryStorage\nfrom aiogram.dispatcher.filters.state import State, StatesGroup\nfrom aiogram.dispatcher import FSMContext\nfrom aiogram import Bot, Dispatcher, executor, types\nfrom config import TOKEN\n\nAPI_TOKEN = TOKEN\n\n# Configure logging\nlogging.basicConfig(\n    format='%(threadName)s %(name)s %(levelname)s: %(message)s',\n    level=logging.INFO\n)\n\n\n# States\nclass Form(StatesGroup):\n    reg_log = State()  # Will be represented in storage as 'Form:reg_log'\n\n\nstorage = MemoryStorage()\n\n# Initialize bot and dispatcher\nbot = Bot(token=API_TOKEN)\ndp = Dispatcher(bot, storage=storage)\n\n\n@dp.message_handler(commands=['start', 'help'])\nasync def send_welcome(message: types.Message):\n    # if await check_login_user(message):\n    #     await check_login_user(message)\n    \"\"\"\n    This handler will be called when user sends `/start` or `/help` command\n    \"\"\"\n    await message.answer(\"Hi!\\nI'm smart home mirea bot!\")\n\n\n@dp.message_handler(commands=['off', 'on'])\nasync def request_to_server(message: types.Message):\n    if await check_login_user(message):\n        await send_text_to_server(message)\n\n\n@dp.message_handler(commands=['status'])\nasync def get_status_sensor(message: types.Message):\n    if await check_login_user(message):\n        with open('commands.csv', 'r') as f:\n            # Создаем объект DictReader, указываем символ-разделитель \",\"\n            file_reader = csv.DictReader(f, delimiter=\",\")\n\n            for row in file_reader:\n                file_read = row['Command']\n\n            await message.answer('Статус датчика: {0}'.format(file_read[1:]))\n\n\n@dp.message_handler()\nasync def echo(message: types.Message):\n    if await check_login_user(message):\n        await message.reply(message.text)\n\n\n@dp.message_handler(state=Form.reg_log)\nasync def registration_or_authorization(message: types.Message, state: FSMContext):\n    async with state.proxy():\n        data_user = message.text.split(',')\n\n        if not await bot_authorization_mode.sign_up(data_user[0], data_user[1]):\n            await bot_reg_mode.set_user(data_user[0],\n                                        message.from_user.id,\n                                        data_user[1])\n            await state.finish()\n\n\nasync def check_login_user(message: types.Message):\n    if not await bot_authorization_mode.check_exist_user(message.from_user.id):\n        await message.answer('Я вижу Вас впервые. Пожалуйста, зарегистрируйтесь '\n                             'или войдите в свой аккаунт!\\n\\n'\n                             'Для этого, просто отправьте мне свой логин и пароль, '\n                             'через запятую БЕЗ пробелов.\\n\\n'\n                             'Пример: login,password')\n        await Form.reg_log.set()\n\n        return False\n\n    return True\n\n\nasync def send_text_to_server(message: types.Message):\n    try:\n        client = base_client.Client('127.0.0.1', 8888).get_client()\n        client.send(message.text.encode('utf-8'))\n\n        await message.answer('Запрос отправлен корректно.')\n    except Exception as e:\n        error_msg = f'Path to file with error : <{__file__}>\\n\\n<CLIENT>: {e}'\n\n        await message.answer(error_msg)\n        print(error_msg)\n\n\nif __name__ == '__main__':\n    executor.start_polling(dp, skip_updates=True)\n",
    "bot_reg_mode.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n# Апишка для регистрации пользователей\n\n# ----------------------------------------------------------------------------------------------------------------------\n\nimport csv\n\nfrom parse_files import create_csv_file_if_not_exists\n\nname_file = 'users.csv'\n\n\nasync def get_user(user_id):\n    await create_csv_file_if_not_exists(name_file)\n\n    with open(name_file, 'r') as f:\n        # Создаем объект DictReader, указываем символ-разделитель \",\"\n        file_reader = csv.DictReader(f, delimiter=\",\")\n        # Считывание данных из CSV файла\n        for row in file_reader:\n            if user_id == row['ID']:\n                return row['Login'], row['ID'], row['Password']\n        else:\n            return None\n\n\nasync def set_user(login, user_id, password):\n    await create_csv_file_if_not_exists(name_file)\n\n    # Запись запроса от бота на сервере в csv - файл\n    with open(name_file, 'a') as f:\n        names = [\"Login\", \"ID\", \"Password\"]\n        file_writer = csv.DictWriter(f, delimiter=\",\",\n                                     lineterminator=\"\\r\", fieldnames=names)\n\n        file_writer.writerow(\n            {\n                names[0]: login,\n                names[1]: user_id,\n                names[2]: password\n            }\n        )\n",
    "main_server.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\nfrom base_server import Server\n\n\nServer('127.0.0.1', 8888)\n",
    "parse_files.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n# API для работы с файлами\n\n# ----------------------------------------------------------------------------------------------------------------------\n\nimport os\nimport csv\nimport codecs\n\n\n# ЭТА ФУНКЦИЯ НЕ РАБОТАЕТ. ДОДЕЛАТЬ ПОТОМ!\nasync def write_data_to_file(data, file):\n    # Проверка на существование файла 'commands.csv'. Если его не будет - создать.\n    if not os.path.exists(file):\n        with open(file, 'w') as f:\n            names = [\"Address\", \"Command\"]\n            file_writer = csv.DictWriter(f, delimiter=\",\",\n                                         lineterminator=\"\\r\", fieldnames=names)\n\n            file_writer.writeheader()\n\n    # Запись запроса от бота на сервере в csv - файл\n    with open(file, 'a') as f:\n        names = [\"Address\", \"Command\"]\n        file_writer = csv.DictWriter(f, delimiter=\",\",\n                                     lineterminator=\"\\r\", fieldnames=names)\n\n        # file_writer.writerow({names[0]: self.transport.get_extra_info('peername'),\n        #                       names[1]: data.decode()})\n\n\nasync def create_csv_file_if_not_exists(loc_name_file, names=None):\n    if names is None:\n        names = [\"Login\", \"ID\", \"Password\"]\n    # Проверка на существование файла 'reg_user.csv'. Если его не будет - создать.\n    if not os.path.exists(loc_name_file):\n        with open(loc_name_file, 'w') as f:\n            file_writer = csv.DictWriter(f, delimiter=\",\",\n                                         lineterminator=\"\\r\", fieldnames=names)\n\n            file_writer.writeheader()\n\n\ndef count_file_in_folder(path, file_name):\n\n    \"\"\"\n    Подсчитывает кол - во файлов в директории.\n\n    :param path:\n        Путь до директории, где мы проверяем кол - во файлов.\n    :param file_name:\n        Строка, которая должна содержаться в имени файла.\n    :return:\n        Возвращает кол - во таких файлов в директории.\n    \"\"\"\n\n    file_name, count_file = str(file_name), 0\n    for i in range(len(os.listdir(path))):\n        if file_name in str(os.listdir(path)[i]):\n            count_file += 1\n\n    return count_file + 1\n\n\ndef count_lines_in_file(path):\n\n    \"\"\"\n    Считает кол-во строк в файле.\n\n    :param path:\n        Путь до файла.\n    :return:\n        Возвращает кол - во строк.\n    \"\"\"\n\n    with codecs.open(path, 'r', 'utf_8') as f:\n        return sum(1 for _ in f)\n\n\ndef attach_file_to_file(path_from, names=None, path_to_save=str(os.getcwd())):\n\n    \"\"\"\n    Объединяет список файлов в один файл.\n\n    :param path_from:\n        Путь до файлов.\n    :param names:\n        Список[] названий этих файлов, включая их тип.\n    :param path_to_save:\n        Путь, куда надо сохранять результирующий файл.\n    :return:\n        Ничего не возвращает.\n    \"\"\"\n\n    for i in range(len(names)):\n        with codecs.open(path_from + str(names[i]), 'r', 'utf_8') as f:\n            print(f.read(), file=codecs.open(path_to_save + '/all_files_result.txt', 'a', 'utf_8'), end='')\n\n\ndef replace_file(path, replace_from, replace_to, bool_list=False):\n\n    \"\"\"\n    Тот же replace только в масштабе файла.\n\n    :param bool_list:\n        Проверка, является ли replace_from списком строк или строкой\n    :param path:\n        Путь до файла.\n    :param replace_from:\n        Строка, которую нужно удалить в файле.\n    :param replace_to:\n        Строка, на которую нужно заменить.\n    :return:\n        Ничего не возвращает.\n    \"\"\"\n\n    with codecs.open(path, 'r', 'utf_8_sig') as f:\n        if bool_list:\n            str_file = f.read()\n            for i in range(len(replace_from)):\n                str_file = str_file.replace(replace_from[i], replace_to)\n\n            print(str_file, file=codecs.open(path + '_new.txt', 'w', 'utf_8'), end='')\n\n        else:\n            print(f.read().replace(replace_from, replace_to),\n                  file=codecs.open(path + '_new.txt', 'w', 'utf_8'), end='')\n\n\ndef del_space(path):\n\n    \"\"\"\n    Удаляет все пустые строки в файле.\n\n    :param path:\n        Путь до файла.\n    :return:\n        Ничего не возвращает.\n    \"\"\"\n\n    with codecs.open(path, 'r', 'utf_8') as f:\n        for _ in range(count_lines_in_file(path)):\n            line = str(f.readline())\n            if line.isspace():\n                continue\n            else:\n                print(line, file=codecs.open(path + 'del_space_RESULT.txt', 'a', 'utf_8'), end='')\n\n\ndef split_file(path):\n\n    \"\"\"\n    Режет один файл на два через строку: _question и _answer\n\n    :param path:\n        Путь до файла\n    :return:\n        Ничего не возвращает.\n    \"\"\"\n\n    with codecs.open(path, 'r', 'utf_8') as f:\n        for (offset, line) in enumerate(f):\n            if offset % 2 == 0:\n                print(line, file=codecs.open(path + '_question', 'a', 'utf_8'), end='')\n            else:\n                print(line, file=codecs.open(path + '_answer', 'a', 'utf_8'), end='')\n",
    "shm_exceptions.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n# Кастомные исключения для проекта\n\n# ----------------------------------------------------------------------------------------------------------------------\n\nclass ExceptionErrorProtocol(Exception):\n    def __init__(self, *args):\n        if args:\n            self.message = args[0]\n        else:\n            self.message = None\n\n    def __str__(self):\n        if self.message:\n            return 'ExceptionErrorProtocol: {0}.'.format(self.message)\n        else:\n            return 'ExceptionErrorProtocol: Unknown protocol!'\n\n\nclass ExceptionErrorCommand(Exception):\n    def __init__(self, *args):\n        if args:\n            self.message = args[0]\n        else:\n            self.message = None\n\n    def __str__(self):\n        if self.message:\n            return 'ExceptionErrorCommand: {0}.'.format(self.message)\n        else:\n            return 'ExceptionErrorCommand: Unknown command!'\n",
    "shm_protocols.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n# Тут будут лежать реализации протоколов.\n\n# ----------------------------------------------------------------------------------------------------------------------\n\nimport asyncio\nimport parse_files\nimport os\nimport csv\n\n\n# TCP протокол\n# ----------------------------------------------------------------------------------------------------------------------\nclass TCPServerProtocol(asyncio.Protocol):\n    # Вызывается если соединение с сервером было\n    # установлено!\n    def connection_made(self, transport):\n        # transport как я понял это\n        # объект соединения\n        peername = transport.get_extra_info('peername')\n        print('<SERVER>: Connection from {}'.format(peername))\n        # Ссылка на transport.\n        self.transport = transport\n\n    # Called when some data is received.\n    # The argument is a bytes object.\n    def data_received(self, data):\n        message = data.decode()\n        # Проверка на существование файла 'commands.csv'. Если его не будет - создать.\n        if not os.path.exists('commands.csv'):\n            with open('commands.csv', 'w') as f:\n                names = [\"Address\", \"Command\"]\n                file_writer = csv.DictWriter(f, delimiter=\",\",\n                                             lineterminator=\"\\r\", fieldnames=names)\n\n                file_writer.writeheader()\n\n        # Запись запроса от бота на сервере в csv - файл\n        with open('commands.csv', 'a') as f:\n            names = [\"Address\", \"Command\"]\n            file_writer = csv.DictWriter(f, delimiter=\",\",\n                                         lineterminator=\"\\r\", fieldnames=names)\n\n            file_writer.writerow({names[0]: self.transport.get_extra_info('peername'),\n                                  names[1]: data.decode()})\n\n        print('<SERVER>: Data received: {!r}'.format(message))\n\n        print('<SERVER>: Send: {!r}'.format(message))\n        self.transport.write(data)\n\n        print('<SERVER>: Close the client socket')\n        # Закрывает соединение после того, как получит\n        # Какой - то запрос.\n        self.transport.close()\n\n    def connection_lost(self, exc):\n        print('<SERVER>: Connection with {} is lost!'.format(self.transport.\n                                                             get_extra_info('peername')))\n# ----------------------------------------------------------------------------------------------------------------------\n",
    "sql_api.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n# api для работы с PostgreSQL\n\n# ----------------------------------------------------------------------------------------------------------------------\n\nimport psycopg2\nfrom config import HOST, USER, PASSWORD, DATABASE\n\nconnection = None\n\ntry:\n    assert isinstance(DATABASE, object)\n    connection = psycopg2.connect(\n        database=DATABASE,\n        user=USER,\n        password=PASSWORD,\n        host=HOST\n    )\nexcept Exception as e:\n    print('ERROR[open_db]: {}'.format(e))\n\n\ndef close_db():\n\n    \"\"\"\n    Закрывает БД\n\n    :return:\n        Ничего не возвращает.\n    \"\"\"\n\n    try:\n        connection.close()\n    except Exception as e:\n        print('ERROR[close_db]: {}'.format(e))\n\n\ndef inquiry_to_db(inquiry, flag=False):\n\n    \"\"\"\n    Принимает SQL-запрос и выполняет его\n\n    :param inquiry:\n        Этот параметр принимает в себя string SQL-запрос.\n    :param flag:\n        Указывает, надо ли выводить на экран отчет о запросе.\n    :return:\n        Ничего не возвращает.\n    \"\"\"\n\n    try:\n        with connection.cursor() as cursor:\n            cursor.execute(inquiry)\n            connection.commit()\n            if flag:\n                return cursor.fetchone()\n    except Exception as e:\n        print('ERROR[inquiry_to_db]: {}'.format(e))\n",
    "test_sensor.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\n\n# Бот отправляет запрос на сервак -> выкл свет.\n# Сервер должен понять что свет выкл. И добавить эту инфу в\n# CSV файл, а бот её оттуда взять и от принтовать в чат\nimport os\nimport time\nimport base_client\nimport csv\nimport asyncio\nimport random\n\n\nfrom shm_exceptions import ExceptionErrorCommand\n\n\nasync def read_file():\n    while True:\n        # try:\n        #     sensor = base_client.Client('127.0.0.1', 8888).get_client()\n        # except Exception as e:\n        #     print(f'<{__file__}>: <CLIENT>: {e}')\n\n        with open('commands.csv', 'r') as f:\n            # Создаем объект DictReader, указываем символ-разделитель \",\"\n            file_reader = csv.DictReader(f, delimiter=\",\")\n\n            for row in file_reader:\n                file_read = row['Command']\n\n            if file_read == '/on':\n                print('<SENSOR> Temperature = {0}°C'.format(random.randint(15, 25)))\n            elif file_read == '/off':\n                print(\"<SENSOR> I'm off!\")\n            else:\n                raise ExceptionErrorCommand('I do not know such a command :(')\n\n        await asyncio.sleep(5)\n\n\nif __name__ == '__main__':\n    asyncio.run(read_file())\n",
    "config.py":"# ======================================================================================================================\n\n# Author: BERKYT\n\n# ======================================================================================================================\n\n# Telegram-bot\n# ----------------------------------------------------------------------------------------------------------------------\n\n# link t.me/smart_home_mirea_bot\nTOKEN = '5062184023:AAF-xY8uVWoZoC4u5WoiAGpf36UyDlqTHV8'\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n# PostgreSQL\n# ----------------------------------------------------------------------------------------------------------------------\n\nHOST = 'localhost'\nUSER = 'postgres'\nPASSWORD = '1488'\nDATABASE = 'postgres'\n\n# ----------------------------------------------------------------------------------------------------------------------\n\n# Server\n# ----------------------------------------------------------------------------------------------------------------------\n\nIP = '127.0.0.1'\nPORT = 1234\n\n# ----------------------------------------------------------------------------------------------------------------------\n"
}